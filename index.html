<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta property="og:title" content="Womganiza" />
  <meta property="og:description" content="Mueve a Otakin para jugar" />
  <meta property="og:image" content="https://womganiza.cl/img/thumbnail.png" />
  <meta property="og:url" content="https://womganiza.cl/" />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Womganiza" />
  <meta name="twitter:description" content="breve resumen de líneas colgado." />
  <meta name="twitter:image" content="https://womganiza.cl/img/thumbnail.png" />
  
  <title>Womganiza v1.0</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0e0f13; color:#fff;   font-family: "Pixel", sans-serif;
  font-optical-sizing: auto; }
    #wrap { position: fixed; inset: 0; display: grid; place-items: center; }
    canvas { width: 100vw; height: 100vh; touch-action: none; display:block; image-rendering: pixelated; }

    .controls {
      position: fixed; left: 50%; bottom: 0.5rem; transform: translateX(-50%);
      display: flex; gap: 1.5rem; justify-content: center; pointer-events: none; width: auto;
    }
	
	 @font-face{
    font-family: "Pixel";
    src: url("./font/PixelifySans-Medium.ttf") format("truetype");
    font-display: swap;
  }

	
    .btn {
      pointer-events: auto;
      border: 1px solid rgba(255,255,255,.15);
      padding: 1.2rem 1.2rem;
	 ont-family: "Pixel", sans-serif;
  font-optical-sizing: auto;
      font-size: 35px;
      border-radius: 14px;
	  
      -webkit-tap-highlight-color: transparent;
      /* bloqueo de selección/callout en móviles */
      user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
      -webkit-touch-callout: none;
      font-weight: 400;
      cursor: pointer;
      transition: transform .08s ease, box-shadow .2s ease, filter .2s ease;
      /* contorno para texto HTML (aplica a "Jugar") */
     
    }
    .btn:active { transform: translateY(1px) scale(.98); }

    /* Izquierda / Derecha: fondo blanco, icono negro (SVG) */
    #left, #right {
      background: #fff;
      color: #111; /* por si hay fallback */
      border-color: rgba(0,0,0,.12);
      box-shadow: 0 6px 18px rgba(0,0,0,.18), inset 0 0 0 1px rgba(0,0,0,.04);
    }
    #left:hover, #right:hover { filter: brightness(0.98); }
    /* tamaño de los SVG dentro de los botones */
    .btn svg { width: 28px; height: 28px; display:block; }

    /* Jugar: verde con “flow” interno */
    #start {
      position: relative;
      color: #fff;
      border: 0;
      background: linear-gradient(90deg, #AC5CFF, #D8B3FF, #AC5CFF);
      background-size: 200% 200%;
      animation: btnGradient 1.5s linear infinite;
      box-shadow: 0 10px 26px rgba(0,200,83,.35);
      overflow: hidden;
    }
    #start::after {
     
    }
    #start:hover { box-shadow: 0 12px 30px rgba(0,200,83,.5); }

    @keyframes btnGradient {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 200% 50%; }
    }
   
    .toast { position: fixed; top: .75rem; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,.5); border: 1px solid rgba(255,255,255,.12); padding: .5rem .75rem; border-radius: 10px; font-size: .85rem; opacity: 0; transition: opacity .25s ease; }
    .toast.show { opacity: 1; }

    /* accesibilidad: texto solo para lectores de pantalla */
    .sr-only {
      position:absolute !important; width:1px; height:1px; padding:0; margin:-1px;
      overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0;
    }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="game"></canvas>
</div>
<div class="controls" id="controls" aria-hidden="true">
  <!-- Flecha izquierda como SVG -->
  <div class="btn" id="left" aria-label="Mover a la izquierda">
    <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
      <path d="M15 6 L9 12 L15 18" fill="none" stroke="#111" stroke-width="3.2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    <span class="sr-only">Izquierda</span>
  </div>
  <!-- Botón jugar (texto) -->
  <div class="btn" id="start">JUGAR</div>
  <!-- Flecha derecha como SVG -->
  <div class="btn" id="right" aria-label="Mover a la derecha">
    <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
      <path d="M9 6 L15 12 L9 18" fill="none" stroke="#111" stroke-width="3.2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    <span class="sr-only">Derecha</span>
  </div>
</div>
<div class="toast" id="toast">Consejo: también puedes arrastrar para mover la cesta</div>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6CDRR81JH8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-6CDRR81JH8');
</script>
<script type="module">

// ===== Fondo único centrado =====
const BG = {
  img: new Image(),
  scale: 'none',     // 'none' | 'contain' | 'cover'
  alignX: 'center',  // 'left' | 'center' | 'right' | número px
  alignY: 'center'   // 'top'  | 'center' | 'bottom' | número px
};

BG.img.src = './img/fondo1.png'; // tu 1024x1536 (o el path que uses)

/** Dibuja el fondo según la escala y centrado */
function drawBackground() {
  if (!BG.img.complete || !BG.img.naturalWidth) return;

  const canW = GAME.width, canH = GAME.height;
  const imgW = BG.img.naturalWidth, imgH = BG.img.naturalHeight;

  let s = 1;
  if (BG.scale === 'contain') {
    s = Math.min(canW / imgW, canH / imgH);
  } else if (BG.scale === 'contain') {
    s = Math.max(canW / imgW, canH / imgH);
  } // 'none' => s = 1

  const w = imgW * s;
  const h = imgH * s;

  // Centrado/alineación
  let x;
  if (typeof BG.alignX === 'number') x = BG.alignX;
  else if (BG.alignX === 'left')     x = 0;
  else if (BG.alignX === 'right')    x = canW - w;
  else                                x = (canW - w) / 2; // center

  let y;
  if (typeof BG.alignY === 'number') y = BG.alignY;
  else if (BG.alignY === 'top')      y = 0;
  else if (BG.alignY === 'bottom')   y = canH - h;
  else                                y = (canH - h) / 2; // center

  ctx.drawImage(BG.img, x, y, w, h);
}




// --- Configuración básica ---
const DPR = Math.min(2, window.devicePixelRatio || 1);
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

// --- Sprites/Imágenes ---
const IMAGES = { player: new Image(), drop: new Image(), logo: new Image(), title: new Image(), bg: new Image(),longa: new Image() };
IMAGES.player.src = './img/otakin_animate.png';
IMAGES.drop.src   = './img/choripan_8bit.png';
IMAGES.logo.src   = './img/womganiza.png';
IMAGES.title.src  = './img/title.png';   // NUEVO (pantalla inicial)
IMAGES.bg.src     = './img/portada.png';      // NUEVO (tile de fondo)
IMAGES.longa.src     = './img/l.png';      // NUEVO (tile de fondo)




// ==== Audio ====
const AUDIO = {
  music: new Audio('./audio/s3.mp3'),
  start: new Audio('./audio/s2.mp3'),
  eat:   new Audio('./audio/s1.mp3'),
  unlocked: false
};
AUDIO.music.loop = true;
AUDIO.music.volume = 0.6;  // música
AUDIO.start.volume = 0.9;  // click/woosh start
AUDIO.eat.volume   = 0.8;  // pop al comer

// iOS/Android: desbloquea audio en primer toque
function unlockAudio() {
  if (AUDIO.unlocked) return;
  AUDIO.unlocked = true;
  // “primer play-pause” para permitir luego reproducir sin bloqueo
  [AUDIO.music, AUDIO.start, AUDIO.eat].forEach(a=>{
    a.muted = false;
    a.play().then(()=>a.pause()).catch(()=>{});
  });
}
document.addEventListener('pointerdown', unlockAudio, { once: true });

// Helpers
function playMusic(restart=false){
  if (restart) AUDIO.music.currentTime = 0;
  AUDIO.music.play().catch(()=>{});
}
function pauseMusic(){ AUDIO.music.pause(); }
function playSfx(sfx){
  try { sfx.currentTime = 0; sfx.play(); } catch {}
}




// Fuente pixel (opcional pero recomendado)
const PIXEL_FONT = new FontFace('Pixel', 'url(./font/PixelifySans-Medium.ttf)');
PIXEL_FONT.load().then(ff => {
  document.fonts.add(ff);
}).catch(()=>{ /* si falla, usa fallback */ });
const controls = {
  left: document.getElementById('left'),
  right: document.getElementById('right'),
  start: document.getElementById('start'),
};
const toast = document.getElementById('toast');

function updateStartButtonLabel() {
  if (GAME.state === 'menu' || GAME.state === 'gameover') controls.start.textContent = 'JUGAR';
  else if (GAME.state === 'playing') controls.start.textContent = 'PAUSA';
  else if (GAME.state === 'paused') controls.start.textContent = 'REANUDAR';
}

const GAME = {
  width: 360,
  height: 640,
  state: 'menu',
  time: 30,
  score: 0,
  lastTime: 0,
  spawnEvery: 500,
  lastSpawn: 0,
};

// --- Título: animación bob/side ---
const TITLE_ANIM = {
  t: 0,
  offX: 0,
  offY: 0,
  // si luego usas sprite sheet de boca, pon frames:2
  frames: 2,      // 1 = una imagen; 2 = sprite (cerrada/abierta)
  mouthFrame: 0,
  mouthTimer: 0
};


// Entidades
const player = {
  w: 150, h: 150, displayW:190, displayH: 190,
  x: 180 - 48, y: 640 - 220,
  speed: 520, vx: 0,
  animFrame: 0, eatingTimer: 0, frameTimer: 0,
};
const drops = []; // {x, y, r, vy}

// --- Util: texto con contorno negro (canvas) ---
function drawTextOutlined(text, x, y, {
  font, color='#fff', align='center', baseline='alphabetic',
  outlineColor='#000', weight=0.28
} = {}) {
  ctx.save();
  if (font) ctx.font = font;
  ctx.textAlign = align;
  ctx.textBaseline = baseline;
  const m = ctx.font.match(/(\d+(?:\.\d+)?)px/);
  const size = m ? parseFloat(m[1]) : 16;
  const lw = Math.max(2, size * weight);
  ctx.lineWidth = lw;
  ctx.lineJoin = 'round';
  ctx.miterLimit = 2;
  ctx.strokeStyle = outlineColor;
  ctx.strokeText(text, x, y);
  ctx.fillStyle = color;
  ctx.fillText(text, x, y);
  ctx.restore();
}

// --- Redimensionamiento responsivo + DPR ---
function resize() {
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  canvas.style.width = vw + 'px';
  canvas.style.height = vh + 'px';
  canvas.width = Math.floor(vw * DPR);
  canvas.height = Math.floor(vh * DPR);
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  GAME.width = vw;
  GAME.height = vh;
  player.y = GAME.height - 260;
  player.x = clamp(player.x, 0, GAME.width - player.displayW);
  //if (!BG_PATTERN) buildBackgroundPattern(ctx);
}
window.addEventListener('resize', resize);
resize();

// --- Utilidades ---
function rnd(min, max) { return Math.random() * (max - min) + min; }
function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function aabb(rect, circle) {
  const nearestX = clamp(circle.x, rect.x, rect.x + rect.w);
  const nearestY = clamp(circle.y, rect.y, rect.y + rect.h);
  const dx = circle.x - nearestX;
  const dy = circle.y - nearestY;
  return (dx * dx + dy * dy) <= (circle.r * circle.r);
}

// --- Entrada táctil / arrastre ---
let dragging = false; let dragOffsetX = 0;
canvas.addEventListener('pointerdown', (e) => {
  dragging = true; canvas.setPointerCapture(e.pointerId);
  const x = e.clientX; dragOffsetX = x - player.x - player.displayW / 2;
});
canvas.addEventListener('pointermove', (e) => {
  if (!dragging) return;
  const x = e.clientX - dragOffsetX;
  player.x = clamp(x - player.displayW / 2, 0, GAME.width - player.displayW);
});
canvas.addEventListener('pointerup', () => { dragging = false; });
canvas.addEventListener('pointercancel', () => dragging = false);

// Botones izquierda / derecha (presión continua)
let leftHeld = false, rightHeld = false;
controls.left.addEventListener('pointerdown', () => leftHeld = true);
controls.left.addEventListener('pointerup', () => leftHeld = false);
controls.left.addEventListener('pointerleave', () => leftHeld = false);
controls.right.addEventListener('pointerdown', () => rightHeld = true);
controls.right.addEventListener('pointerup', () => rightHeld = false);
controls.right.addEventListener('pointerleave', () => rightHeld = false);

// Botón Jugar
controls.start.addEventListener('click', () => {
  if (GAME.state === 'menu' || GAME.state === 'gameover') {
    startGame();
  } else if (GAME.state === 'playing') {
    pauseGame();
  } else if (GAME.state === 'paused') {
    resumeGame();
  }
});

// Teclas (debug desktop)
window.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowLeft') leftHeld = true;
  if (e.key === 'ArrowRight') rightHeld = true;
  if (e.key.toLowerCase() === ' ') startGame();
});
window.addEventListener('keyup', (e) => {
  if (e.key === 'ArrowLeft') leftHeld = false;
  if (e.key === 'ArrowRight') rightHeld = false;
});

// Orientación (opcional): inclinar para mover
window.addEventListener('deviceorientation', (e) => {
  if (GAME.state !== 'playing') return;
  const tilt = (e.gamma || 0);
  player.vx = clamp(tilt * 18, -720, 720);
});

// --- Lógica del juego (igual que tenías) ---
function startGame() {
  GAME.state = 'playing';
  GAME.score = 0;
  GAME.time = 30;
  GAME.lastSpawn = 0;
  drops.length = 0;
  
   playSfx(AUDIO.start);   // 🔊 SFX Start
  playMusic(true);        // 🎵 música en loop (reinicia al empezar)
  
  showToast('¡Atrapa todos los choripanes!');
  updateStartButtonLabel();
}
function endGame() {
  GAME.state = 'gameover';
    pauseMusic();           // (opcional) pausar al terminar

  showToast(`Fin del juego. Puntos: ${GAME.score}`);
  updateStartButtonLabel();
}
function pauseGame() {
  GAME.state = 'paused';
    pauseMusic();           // pausa música

  showToast('Juego en pausa');
  updateStartButtonLabel();
}
function resumeGame() {
  GAME.state = 'playing';
    playMusic(false);       // reanuda música

  showToast('Juego reanudado');
  updateStartButtonLabel();
}
function spawnDrop() {
  const r = rnd(16, 28);
  drops.push({ x: rnd(r, GAME.width - r), y: -r - 10, r, vy: rnd(260, 420) });
}
function update(dt) {
  
  
  
  
  if (player.eatingTimer > 0) {
    player.eatingTimer -= dt;
    player.frameTimer  -= dt;
    if (player.frameTimer <= 0) {
      player.frameTimer = 0.1;
      player.animFrame = 1 - player.animFrame;
    }
    if (player.eatingTimer <= 0) player.animFrame = 0;
  }
  
  
  
  
  if (GAME.state === 'menu' || GAME.state === 'gameover' || GAME.state === 'paused') return;

  let vx = 0;
  if (leftHeld) vx -= player.speed;
  if (rightHeld) vx += player.speed;
  vx = vx || player.vx || 0;
  player.x = clamp(player.x + vx * dt, 0, GAME.width - player.displayW);

  GAME.lastSpawn += dt * 1000;
  const dynamicSpawnMs = Math.max(260, GAME.spawnEvery - GAME.score * 8);
  if (GAME.lastSpawn >= dynamicSpawnMs) { spawnDrop(); GAME.lastSpawn = 0; }

  for (let i = drops.length - 1; i >= 0; i--) {
    const d = drops[i];
    d.y += d.vy * dt;
    const playerHitbox = { x: player.x, y: player.y, w: player.displayW, h: player.displayH };
    if (aabb(playerHitbox, d)) {
      drops.splice(i, 1);
      GAME.score += 1;
	  
	      // ===== Parte 4: SFX comer + screen shake opcional =====
    playSfx(AUDIO.eat);      // sonido de “comer”
    //triggerShake(100, 3);    // (opcional) pequeña vibración de cámara
    // ======================================================
	  
	  
      player.eatingTimer = 0.5;
      continue;
    }
    if (d.y - d.r > GAME.height + 40) drops.splice(i, 1);
  }

  GAME.time -= dt;
  if (GAME.time <= 0) { GAME.time = 0; endGame(); }




}

// --- Dibujo ---
function draw() {
  // Fondo según estado
  drawBackground();

  if (GAME.state === 'menu') { drawTitle(); return; }
  
  if (AUDIO.unlocked && AUDIO.music.paused) {
  playMusic(true);   // arranca la música en loop ya en la pantalla de intro
}


  drawPlayer();

  for (const d of drops) {
    if (IMAGES.drop.complete && IMAGES.drop.naturalWidth > 0) {
      const size = d.r * 2;
      ctx.drawImage(IMAGES.drop, d.x - d.r, d.y - d.r, size, size);
    } else {
      ctx.beginPath();
      ctx.arc(d.x, d.y, d.r, 0, Math.PI * 2);
      ctx.closePath();
      ctx.fillStyle = '#45caff';
      ctx.fill();
    }
  }

  drawHUD();

  if (GAME.state === 'gameover') drawGameOver();
  if (GAME.state === 'paused') drawPause();
}

function drawTitle() {
  ctx.save();
  ctx.textAlign = 'center';
  if (IMAGES.logo.complete && IMAGES.logo.naturalWidth > 0) {
    const logoWidth = 390;
    const scale = logoWidth / IMAGES.logo.naturalWidth;
    const logoHeight = IMAGES.logo.naturalHeight * scale;
    const logoX = (GAME.width - logoWidth) / 2;
    const logoY = GAME.height * 0.00;
    ctx.drawImage(IMAGES.logo, logoX, logoY, logoWidth, logoHeight);
  }
  


// IMAGEN DE OTKIN EN LA PORTADA (con bob + side)
// Soporta 1 imagen o sprite sheet de 2 frames (ver sección 2)
if (IMAGES.bg.complete && IMAGES.bg.naturalWidth > 0) {
  // si frames=2, el ancho "nativo" de cada frame es la mitad
  const natFrameW = (TITLE_ANIM.frames === 2)
    ? IMAGES.bg.naturalWidth / 2
    : IMAGES.bg.naturalWidth;

  const natFrameH = IMAGES.bg.naturalHeight;

  const maxW = Math.min(GAME.width * 1, 600);
  const s = Math.min(maxW / natFrameW, 1);

  const w = natFrameW * s;
  const h = natFrameH * s;

  const x = (GAME.width - w) / 2 + TITLE_ANIM.offX;
  const y = GAME.height * 0.37 + TITLE_ANIM.offY;

  // fuente dentro del sprite si hay 2 frames
  const srcX = (TITLE_ANIM.frames === 2 ? TITLE_ANIM.mouthFrame * natFrameW : 0);
  const srcY = 0;

  ctx.drawImage(IMAGES.bg, srcX, srcY, natFrameW, natFrameH, x, y, w, h);
}


// IMAGEN DE LONGA EN LA PORTADA (bob/tilt suave, sin sprite-sheet)
if (IMAGES.longa.complete && IMAGES.longa.naturalWidth > 0) {
  const natW = IMAGES.longa.naturalWidth;
  const natH = IMAGES.longa.naturalHeight;

  const maxW = Math.min(GAME.width * 1.0, 250);
  const s = Math.min(maxW / natW, 1);

  const w = natW * s;
  const h = natH * s;

  // posición base centrada + offsets de animación
  const baseX = (GAME.width - w) / 2;
  const baseY = GAME.height * .62;
  const x = baseX + TITLE_ANIM.offX;
  const y = baseY + TITLE_ANIM.offY;

  // rotación leve (opcional). Quita estas 3 líneas si no quieres tilt:
  const tilt = Math.sin(TITLE_ANIM.t * 5.9) * (Math.PI / 180) * 2; // ±2°
  ctx.save();
  ctx.translate(x + w/2, y + h/2);
  ctx.rotate(tilt);

  // dibuja la imagen completa (sin partirla)
  const srcX = 0, srcY = 0, srcW = natW, srcH = natH;
  ctx.drawImage(IMAGES.longa, srcX, srcY, srcW, srcH, -w/2, -h/2, w, h);

  ctx.restore();
}



  
  drawTextOutlined('MUEVE A OTAKIN PARA ATRAPARLOS', GAME.width/2, GAME.height * 0.36, {
    font: '400 22px Pixel, Inter, system-ui, sans-serif', color: '#fff'
  });
  drawTextOutlined('TOCA "JUGAR" PARA COMENZAR (30s)', GAME.width/2, GAME.height * 0.39, {
    font: '400 17px Pixel, Inter, system-ui, sans-serif', color: '#ffffff'
  });
  ctx.restore();
}

function drawPlayer() {
  const sourceX = player.animFrame * player.w;
  const sourceY = 0;
  if (IMAGES.player.complete && IMAGES.player.naturalWidth > 0) {
    ctx.drawImage(
      IMAGES.player, sourceX, sourceY, player.w, player.h,
      player.x, player.y, player.displayW, player.displayH
    );
  } else {
    ctx.fillStyle = 'rgba(255,255,255,.18)';
    ctx.fillRect(player.x, player.y, player.displayW, player.displayH);
  }
}

function drawHUD() {
  drawTextOutlined('CHORIPANES: ' + GAME.score, 16, 30, {
    font: '100 25px Pixel, Inter, system-ui, sans-serif', color: '#fff', align: 'left'
  });
  drawTextOutlined('TIEMPO: ' + Math.ceil(GAME.time), GAME.width - 16, 30, {
    font: '100 25px Pixel, Inter, system-ui, sans-serif', color: '#fff', align: 'right'
  });
}

function drawGameOver() {
  drawTextOutlined('COMISTE:', GAME.width/2, GAME.height*0.40, {
    font: '100 26px Pixel, Inter, system-ui, sans-serif', color: '#fff'
  });
  drawTextOutlined(`${GAME.score} CHORIPANES`, GAME.width/2, GAME.height*0.47, {
    font: '100 50px Pixel, system-ui, sans-serif', color: '#fff'
  });
  drawTextOutlined('Felicitaciones', GAME.width/2, GAME.height*0.51, {
    font: '100 16px Pixel, system-ui, sans-serif', color: '#fff'
  });
}

function drawPause() {
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.fillRect(0,0,GAME.width,GAME.height);
  ctx.restore();
  drawTextOutlined('PAUSA', GAME.width/2, GAME.height*0.42, {
    font: '900 24px Inter, system-ui, sans-serif', color: '#fff'
  });
  drawTextOutlined('Toca Reanudar para continuar', GAME.width/2, GAME.height*0.47, {
    font: '900 16px Inter, system-ui, sans-serif', color: '#fff'
  });
}

function loop(now) {
  if (!GAME.lastTime) GAME.lastTime = now;
  const dt = Math.min(0.033, (now - GAME.lastTime) / 1000);
  
  // actualizar anim de portada aunque estemos en menú
TITLE_ANIM.t += dt;
TITLE_ANIM.offX = Math.sin(TITLE_ANIM.t * 2.2) * 6;  // left-right
TITLE_ANIM.offY = Math.sin(TITLE_ANIM.t * 1.6) * 3;  // "breathing"

// alternar boca cada ~0.12s (ajusta a gusto)
TITLE_ANIM.mouthTimer += dt;
if (TITLE_ANIM.mouthTimer >= 0.32) {
  TITLE_ANIM.mouthTimer = 0;
  TITLE_ANIM.mouthFrame = 1 - TITLE_ANIM.mouthFrame; // 0 <-> 1
}

  
  GAME.lastTime = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

function showToast(msg, ms = 2000) {
  toast.textContent = msg;
  toast.classList.add('show');
  clearTimeout(showToast._t);
  showToast._t = setTimeout(() => toast.classList.remove('show'), ms);
}

document.addEventListener('visibilitychange', () => {
  if (document.hidden && GAME.state === 'playing') {
    GAME.lastTime = performance.now();
  }
});

function updateControlsVisibility() {
  const visible = true;
  document.getElementById('controls').style.display = visible ? 'flex' : 'none';
}
updateControlsVisibility();

GAME.state = 'menu';
showToast('Consejo: también puedes inclinar el teléfono');
updateStartButtonLabel();

let lastTouchEnd = 0;
document.addEventListener('touchend', function (event) {
  const now = new Date().getTime();
  if (now - lastTouchEnd <= 300) {
    event.preventDefault(); // bloquea el zoom por doble tap
  }
  lastTouchEnd = now;
}, false);

</script>
</body>
</html>
